---
title: "Working with Data Frames Part I"
output: html_notebook
---

# Introduction to Data Frames

We have seen that "tabular" data such as is typically entered into an excel spreadsheet and then saved as a csv or other common file format is represented as a **data frame** when imported into R. In fact, a data frame is the most common way of storing data in R. Here we will look further into the data frame structure. 

**Python side note** The pandas library enables one to work with data frames in Python in a manner very similar to what is done in R.

**Warning** The material presented in this notebook is very important even if somewhat dry. 

In R a **data frame** is a **list** of **vectors** that all have the same length. Remember this forever! The point here is that in order to fully understand data frames, we have to know something about vectors and lists. 

# Vectors and Lists

Vectors (at least atomic vectors) should be reasonably familiar to you from the swirl lessons. Just as a quick recap, a (atomic) vector is an ordered collection of objects that all have the same type. Vectors are created via concatenation c(). 

Here are some examples:
```{r}
a_vect <- c(1.1,-2.2,3.7)
b_vect <- c("a","b","c","d")
c_vect <- c(1L,2L,3L,4L,5L)
```

Notice the following:
```{r}
print(typeof(a_vect)) # says that each element of a_vect is a double 
print(typeof(b_vect)) # says that each element of b_vect is a character 
print(typeof(c_vect)) # says that each element of c_vect is an integer 
```

What happens if we try to create a vector that has different types of elements? For example
```{r}
aa_vect <- c(1.2,1L,"cat")
```

Let's check the type of aa_vect:
```{r}
typeof(aa_vect)
```


**Question:** What happened here? 

The important point to take away is that there is a heirarchy of types in R and the consequence of this is that if you try to mix types in an vector (where every element must be of the same type) you get **type conversion.**

Note that in instances of type conversion, integers get converted to doubles and doubles get converted to characters. 

**Question:** Why do you think it could be a problem for say a double to get converted to a character somewhere in a data analysis? 

It is possible to manually convert types, for example:
```{r}
bb <- 2.3
print(typeof(bb))
print(as.character(bb))
print(as.integer(bb))
```

**Question** Explain the previous results. 

Lists are handy when you want to mix types without type conversion. A list is a list of R objects of **any** type. You create a list with the list function. For example,
```{r}
a_list <- list(1:3,"a",c(1.2,3.4,-5.6),c("hello","everybody"))
```

Let's see what happens if we print this list:
```{r}
print(a_list)
```

What if we request the type of a list?
```{r}
typeof(a_list)
```

Recall that we can individually access the elements in a vector using indexing. For example, 
```{r}
a_vect[1]
```

or

```{r}
a_vect[2]
```

We can **slice** vectors as well. For example:
```{r}
b_vect[1:3]
```

or even

```{r}
b_vect[c(2,4)]
```


How does indexing work with a list? Let's examine this.

```{r}
a_list[1]
```

**Question:** What did this do?

It is actually considered better practice to do this instead:
```{r}
a_list[[1]]
```

Now we can also do things such as
```{r}
a_list[c(1,4)]
```

Notice that since the third element of a_list is a vector, we can use indexing on a_list[[3]] for :
```{r}
a_list[[3]][2]
```

The entries of lists (and vectors as well) can be given reference names. For example,
```{r}
aa_list <- list(three=1:3,a="a",my_vect=c(1.2,3.4,-5.6),my_words=c("hello","everybody"))
```

Let's print this:
```{r}
print(aa_list)
```

Names are an attribute of a list. For example,
```{r}
attributes(aa_list)
```

A full discussion of attributes of R objects would take us far off topic. If you want to know more about this, see [Advanced R](http://adv-r.had.co.nz/) by Hadley Wickham. 

The use of naming is that now we can refer to elements of a list by name:
```{r}
aa_list$my_vect
```

Then indexing still works as
```{r}
aa_list$my_vect[2]
```


If you have a named vector such as
```{r}
named_vect <- c(a=2.1,b=7.6,c=-5.6)
```

you can also access the vectors elements via names as
```{r}
named_vect["c"]
```

**Note:** Remember that we said that a list can contain as an element **any** R object. Specifically, lists can contain other lists as elements. For example,
```{r}
bb_list <- list(vec_a=c(5,9,2.2,37),list_a=list(one=c(3,2,1),two=c("J","M","G")))
```

Let's print the contents of bb_list
```{r}
print(bb_list)
```
The fact that lists can contain any R object as an element makes lists extremely powerful. One of the most common applications of lists (besides in the context of their relationship to data frames) is that many functions return the output as a list. 

**Note:** It is possible to convert an R object to as list with the as.list() function. It is also possible to "unlist" a list object with the unlist() function.  

Now we know enough to begin to look at data frames which is what we are most interested in anyway. 

# Data Frames

Data frames are created with data.frame(). For example
```{r}
aa_df <- data.frame(c(5,4,3,2,1),c("Mary","Steven","Jon","Tasha","Shannon"))
```
Take care to make sure that each vector element of the data frame has the same length. 

Let's print our data frame:
```{r}
print(aa_df)
```

It's important (and as we will see later useful) to know what are the attributes of a data frame:
```{r}
attributes(aa_df)
```

The point to take away here is that data frames have a (column) names atttribute and an row.names attribute. **If these are not specified in the definition of the data frame then they get default values.**

The lesson here is that when you construct a data frame (even if it is done by importing data from a file) you should specify at least the (column) names. So what we should have done is somehting like this:
```{r}
bb_df <- data.frame(col1=c(5,4,3,2,1),col2=c("Mary","Steven","Jon","Tasha","Shannon"))
```

Let's examine bb_df:
```{r}
print(bb_df)
```

and

```{r}
attributes(bb_df)
```


also useful
```{r}
str(bb_df)
```

**Note:** There is an important subtlety in the construction of data frames that we need to highlight. By default, the data.frame() function converts strings to factors. That is why we see the term "Factor" in the output to sttr() above. We will see in a moment why this is an important point. For now, let's spell out in more detail what it means to converts strings to factors. 

Consider the following:
```{r}
col2<-c("Mary","Steven","Jon","Tasha","Shannon")
typeof(col2)
```
Based on this we see that the col2 just created is a character vector. Now consider
```{r}
typeof(bb_df$col2)
```
Why do we get this result? Observe
```{r}
print(bb_df$col2)
```
and
```{r}
attributes(bb_df$col2)
```

On the other hand
```{r}
attributes(col2)
```

What this tells us is that the character vector col2 has NULL (think of this as R's way of representing nothing) attributes
while bb_df$col2 has two attributes called levels  and class with class value factor. This tells us that bb_df\$col2 is a factor (we will say exactly what this means in a moment) **even though when we created bb_df we entered col2 as a character vector.**

The reason this all matters is because when you import a data table, say from a csv or excel spreadsheet into R with a read.table type function, by default it will convert strings into factors. This means that columns in the data frame corresponding to categorical (or qualitative)  variables will be represented in R as factors. So what is a factor?

## Side note on factors

A factor is a vector that can contain only predefined values, and is used to store categorical data. Factors are built on top of integer vectors. The integer determines the number of times each lelvel value occurs. How you construct a factor typically depends on how you want to use your data. Here are two common ways to create a factor.

```{r}
a_factor <- factor(c("Jon","Mary","George","Alex","Carrie"))
b_factor <- factor(c("A","B","C","A","A","B"),levels = c("A","B","C","D","F"))
```

Let's print these:
```{r}
print(a_factor)
```


```{r}
print(b_factor)
```

**Important point** If you don't specify the levels in a factor R sets default values for the levels based on the data vector. Also, as illustrated with the b_factor example, level values do not need to appear in the observed data. Factors are most useful when you know in advance the complete list of possible values that a categorical variable can take.  

A nice thing about factors is that they correspond perfectly to tables and barplots. For example, 
```{r}
table(b_factor)
```

```{r}
barplot(table(b_factor))
```

One final note about factors before going back to data frames. As stated, when a csv file is imported, and categorical variables get represented as a factor by default. For example. 
```{r}
df_w_factors <- read.csv("https://raw.githubusercontent.com/fivethirtyeight/data/master/bechdel/movies.csv")
```

Let's call str() on this:
```{r}
str(df_w_factors)
```

It is possible to control this behavior by changing the value of an optional argument in read.csv from what is default. For example,
```{r}
df_wo_factors <- read.csv("https://raw.githubusercontent.com/fivethirtyeight/data/master/bechdel/movies.csv",stringsAsFactors = F)
```

Let's call str() again,
```{r}
str(df_wo_factors)
```

**Question** Do you notice the difference? 

Sometimes it is useful to represent categorical variables as factors and sometimes it is not. We will see this by way of examples as we progress through the course. The most important idea to grasp is simply that you need to pay attention to notice whether strings get converted to factors or not and if in case they do and this is undesirable, what can you do about it. In part II of working with data frames we will see how to exploit the data frame structure in order to do useful things.   